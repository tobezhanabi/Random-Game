// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";

contract RandomWinnerGame is VRFConsumerBase, Ownable {
  // link token to send with the request
  uint256 public fee;
  // iD of public key againt which randomness is generated
  bytes32 public keyHash;
  // Address of the players
  address[] public players;
  // max number of players in one game
  uint8 maxPlayers;
  //variable to indicate if the game has started or not
  bool public gameStarted;

  // fee for entering the game
  uint256 entryFee;
  //current game Id
  uint256 public gameId;

  //emiitted when the game starts
  event GameStarted(uint256 gameId, uint8 maxPlayers, uint256 entryFee);
  // emitted when someone joins the game
  event PlayerJoined(uint256 gameId, address player);
  // when games end
  event GameEnded(uint256 gameId, address winner, bytes32 requestId);

  /**
   * constructor inherits a VRFConsumerBase and initiates the values for keyHash, fee and gameStarted
   * @param vrfCoordinator address of VRFCoordinator contract
   * @param linkToken address of LINK token contract
   * @param vrfFee the amount of LINK to send with the request
   * @param vrfKeyHash ID of public key against which randomness is generated
   */

  constructor(
    address vrfCoordinator,
    address linkToken,
    bytes32 vrfKeyHash,
    uint256 vrfFee
  ) VRFConsumerBase(vrfCoordinator, linkToken) {
    keyHash = vrfKeyHash;
    fee = vrfFee;
    gameStarted = false;
  }

  function startGame(uint8 _maxPlayers, uint256 _entryFee) public onlyOwner {
    require(!gameStarted, "Game is ongoing");
    // empty the players array
    delete players;
    // set the max players for this game
    maxPlayers = _maxPlayers;
    // set the game started to true
    gameStarted = true;
    entryFee = _entryFee;
    gameId += 1;
    emit GameStarted(gameId, maxPlayers, entryFee);
  }

  function joinGame() public payable {
    require(gameStarted, "Game is starting soon");
    require(msg.value == entryFee, "value sent is not equal to entryFee");
    require(players.length < maxPlayers, "game is full");
    players.push(msg.sender);
    emit PlayerJoined(gameId, msg.sender);
    if (players.length == maxPlayers) {
      getRandomWinner();
    }
  }

  /**
   * fulfillRandomness is called by VRFCoordinator when it receives a valid VRF proof.
   * This function is overrided to act upon the random number generated by Chainlink VRF.
   * @param requestId  this ID is unique for the request we sent to the VRF Coordinator
   * @param randomness this is a random unit256 generated and returned to us by the VRF Coordinator
   */

  function fulfillRandomness(
    bytes32 requestId,
    uint256 randomness
  ) internal virtual override {
    //We want out winnerIndex to be in the length from 0 to players.length-1
    // For this we mod it with the player.length value
    uint256 winnerIndex = randomness % players.length;
    // get the address of the winner from the players array
    address winner = players[winnerIndex];
    // send the ether in the contract to the winner
    (bool sent, ) = winner.call{ value: address(this).balance }("");
    require(sent, "failed to send Ether");
    //emit that the game ends
    emit GameEnded(gameId, winner, requestId);
    gameStarted = false;
  }

  /**
   * getRandomWinner is called to start the process of selecting a random winner
   */
  function getRandomWinner() private returns (bytes32 requestId) {
    // LINK is an internal interface for Link token found within the VRFConsumerBase
    // Here we use the balanceOF method from that interface to make sure that our
    // contract has enough link so that we can request the VRFCoordinator for randomness
    require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK");
    // Make a request to the VRF coordinator.
    // requestRandomness is a function within the VRFConsumerBase
    // it starts the process of randomness generation
    return requestRandomness(keyHash, fee);
  }

  // Function to receive Ether. msg.data must be empty
  receive() external payable {}

  // Fallback function is called when msg.data is not empty
  fallback() external payable {}
}
